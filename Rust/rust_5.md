# 러스트의 소유권(Ownership) 이해하기

## 소유권이란?

소유권(Ownership)은 러스트의 가장 유니크한 특성이며, 러스트가 가비지 콜렉터 없이 메모리 안정성 보장하게 해준다고 한다. 따라서, 소유권이 러스트 내에서 어떻게 동작하는지 이해하는 것은 중요하다. 또한 메모리에 데이터를 저장하는지도 알아보자.

<br>

## 소유권의 규칙

다음 내용인 `소유권의 규칙`이란 것을 명심하고 넘어가야 한다

- 러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다. 
- 한번에 딱 하나의 오너만 존재할 수 있다.
- 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).

<br>

## 변수의 스코프

스코프란 '프로그램 내에서 변수가 유효하다는 것을 표시하기 위한 범위'를 뜻한다.
 
```rust
fn main() {
    {   // s는 유효하지 않습니다. 아직 선언이 안됐거든요.
        let s = "hello";   // s는 이 지점부터 유효합니다.
    
        // s를 가지고 뭔가 합니다.
    }   // 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.
}
```

변수 `s`는 스트링 리터럴을 나타내는데, 스트링 리터럴의 값은 프로그램의 텍스트 내에 하드코딩되어 있다. 변수는 선언된 시점부터 현재의 스코프가 끝날 때까지 유효합니다.
여기서 두가지 포인트를 찾을 수 있다.

- 스코프 안에서 s가 등장하면, 유효한 변수이다. 
- 이 유효기간은 스코프 밖으로 벗어날 때까지 지속됩니다.

<br>

## String타입을 예시로 활용하여 알아보는  소유권, 스코프의 관계

소유권 규칙을 설명하기 위하여, 더 복잡한 데이터 타입이 필요하다. 우리가 이전에 봐온 모든 데이터 타입들(스칼라 타입)은 스택에 저장되었다가 스코프를 벗어날 때 스택으로부터 팝 됩니다, 우리는 이제 힙에 저장되는 데이터를 관찰하고 러스트는 과연 어떻게 이 데이터를 비워내는지 설명할 필요가 있습니다.

String 타입은 힙에 할당되고 컴파일 타임에는 우리가 알 수 없는 양의 텍스트를 저장할 수 있습니다. 스트링 리터럴로부터 from이라는 함수를 이용해서 String을 아래처럼 만들 수 있습니다.

```rust
fn main() {
    let s = String::from("hello");
}
```

더블 콜론(::)은 우리가 string_from과 같은 이름을 쓰기 보다는 String 타입 아래의 from 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자이다. 이러한 문법에 대해 "메소드 문법" 부분에서 더 자세히 다룰 것이고, 모듈에서의 네임스페이스와 관련한 내용은 나중에 알아보자.

```rust
fn main() {
    let mut s = String::from("hello");
    
    s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.
    
    println!("{}", s); // `hello, world!`를 출력.
}
```

스트링 리터럴의 경우, 우리는 내용물을 컴파일 타임에 알 수 있으므로 텍스트가 최종 실행파일에 직접 하드코딩 되었고, 이렇게 하면 스트링 리터럴이 빠르고 효율적이 됩니다. 그러나 이는 문자열이 변경되지 않는 것을 전재로 하는 특성입니다. 컴파일 타임에 크기를 알 수 없는 변수일 경우, 실행 중 크기가 변할 수도 있는 경우의 텍스트 조각을 바이너리 파일에 집어넣을 수 없다.

String 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 우리는 힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 메모리 공간을 할당받아 내용물을 저장할 필요가 있다. 이는 즉 다음과 같은 조건을 요구한다.

- 런타임에 운영체제로부터 메모리가 요청되어야 한다.
- String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다.

첫번째 조건은 개발자가 직접 수행한다. String::from을 호출하면, 구현부분에서 필요한 만큼의 메모리를 요청합니다. 이는 프로그래밍 언어들 사이에서 매우 일반적입니다.

하지만, 두번째 조건은 다르다. 가비지 콜렉터(GC) 를 갖고 있는 언어들의 경우, GC가 더이상 사용하지 않는 메모리 조각을 계속해서 찾고 지워주며, 프로그래머로서 이와 관련한 생각을 안해도 된다. GC가 없을 경우, 할당받은 메모리가 더 필요없는 시점을 알아서 명시적으로 이를 반납하는 코드를 호출하는 것은 개발자의 책임이다. 이를 올바르게 하는 것은 역사적으로 어려운 문제로 취급받아왔고, 메모리 해제를 까먹는 다면 메모리를 낭비하는 것이다. 그렇다고 너무 빨리 반납해버리면? 유효하지 않은 변수를 갖게 되는 것이다. 만약에 메모리 반납을 두번 수행하면? 이것도 버그를 발생시킨다. 우리는 딱 한번의 allocate와 한번의 free 쌍을 사용할 필요가 있다.

러스트는 다른 방식으로 이 문제를 다룹니다: 메모리는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납된다.

```rust
fn main() {
    {
        let s = String::from("hello"); // s는 여기서부터 유효하다
    
        // s를 가지고 무언가를 합니다
    }   // 이 스코프는 끝났고, s는 더 이상 유효하지 않은 변수
}
```

String이 요구한 메모리를 운영체제에게 반납하는 자연스러운 지점이 있는데 그것은 s가 스코프 밖으로 벗어날 때이다. 변수가 스코프 밖으로 벗어나면, 러스트는 내부적으로 특별한 함수를 호출한다. 이 함수를 `drop`이라고 부르고, 개발자가 메모리를 반환하도록 하는 코드를 집어넣을 수 있습니다. 그러나 러스트는 `}` 괄호가 닫힐때 자동적으로 `drop`을 호출합니다.

이 패턴은 러스트 코드가 작성되는 방법에 깊은 영향을 주는 요소이며, 지금은 단순해 보이시겠지만 우리가 힙에 할당시킨 데이터를 사용하는 여러 개의 변수를 사용하고자 할 경우와 동시에 좀 더 복잡한 상황에서, 코드의 동작은 예기치 못한 상황을 발생시킬 수 있다.

### 변수와 데이터가 상호작용하는 방법: 이동(move)

### 변수와 데이터가 상호작용하는 방법: 클론(clone)

### 스택에만 있는 데이터: 복사


## 소유권과 함수

## 반환 값과 스코프

<br>

### 참조
- https://rinthel.github.io/rust-lang-book-ko/ch04-01-what-is-ownership.html
