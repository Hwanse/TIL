
# 예상 독자
- 코드를 쉽게 읽고, 테스트하고, 유지 운영하길 원하는 개발자들을 위한 책
- Go언어를 통해 더 많은 것을 구현하길 원하는 객체지향에 익숙한 개발자에게 적합

## DI가 필요한 코드 냄새
DI는 프로그래밍 분야에서 매우 유용한 도구로 활용되나 특정 상황에 국한되어 있음. 이 책에서 말하는 DI가 필요한 특정상황은
바로 '코드 냄새'를 말하며, 코드 냄새란 다음과 같은 유형을 말한다

- 코드 팽창(code bloat)
- 변경에 대한 저항(resistance to change)
- 낭비되는 노력(wasted effort)
- 강한 결합(tight coupling)

### 코드 팽창
코드 팽창은 너무 길거나 읽기 힘든 수준의 코드가 구조체 또는 함수에 추가되어 이해가 어렵고 유지 운영 및 테스트가 힘든 경우를
말한다. 코드 팽창 냄새는 소스 코드를 정적 분석을 하거나 gocyclo 같은 순환 복잡도 검사기를 통해 찾을 수 있음.
다음과 같은 특징을 포함하는 코드가 '코드 팽창' 냄새가 나는 코드라 할 수 있다

- 너무 긴 메서드
- 거대한 구조체
- 너무 많은 인수(매개변수)
- 너무 긴 조건 블록

### 변경에 대한 저항
새로운 기능이 추가하는 행위가 어렵거나 오랜 시간을 소요하게 만드는 코드를 의미하며, 이러한 상황을 변경에 대한 저항성을 가진 코드라고 말한다. 변경에 저항을 가지는 코드는 다음과 같은 특징을 포함

- 변경의 분산: 하나의 작은 변경을 했을 경우 다른 코드에도 변경이 필요한 상황을 의미. 간단한 변경을 했을 뿐인데 많은 부분의 코드를 수정하는 것.
- 상세 구현 내용 노출: 예로 함수의 매개변수로 구조체를 전달받을 경우 해당 함수를 사용하는 사용자의 코드가 특정 조건에 제한된
동작 구현을 하게되고, 만일 함수의 세부 구현 내용이 변경될 경우 API가 변경되고 해당 함수의 사용자 또한 변경되는 상황.
  
### 낭비되는 노력
코드를 유지 운영하는 비용이 필요 이상으로 높은 상황을 말함. 노력이 낭비되는 상황을 유발하는 코드 유형은 다음과 같음

- 과도하게 중복된 코드
- 과도한 주석
- 중첩되고 복합한 코드
- DRY/WET 코드: DRY(Don't Repeat Yourself/중복 배제)는 책임을 그룹화하여 깔끔하게 정리된 추상화를 통해 개발 과정에서
모든 형태의 중복을 지향하는 원칙, 이와 대조적으로 WET(Waste Everyone's Time) 코드에서는 동일한 책임이 여러 곳에 산재되어
  있는 상황을 말함.
  
### 강한 결합
결합은 각 객체들이 서로 관련되어 있거나 의존하는 정도를 말하며, 두 객체 간에 결합의 정도가 강할 수록 상호 의존성 또한 강해져
한 객체가 변경되면 다른 객체도 그에 맞춰 같이 변경되는 상황을 말하고 이 또한 유지 운영 비용을 증가시키는 요소. 강한 결합 냄새가 나는 코드는 다음과 같은 특징을 포함함

- 신(God) 객체에 대한 의존: '신 객체'는 너무 많은 것을 알고 있거나 너무 많은 일을 수행하는 객체를 의미. 즉 하나의 객체에 너무 많은 코드가 의존하고 있는 상황
- 순환 종속성: Go 언어에서는 패키지 순환 참조를 의미
- 객체 섞임: 한 객체가 다른 객체의 내부 구조에 대해 너무 많이 알고 있거나 너무 많은 접근 권한을 가지고 있는 상황, 이럴 경우 한 객체가 변경되면 다른 객체도 변경되는 상황을 유발
- 요요 문제: 상속 관계가 너무 길고 복잡화 되어 개발자가 이 코드를 이해하기 위해서 서로 다른 부분을 계속 훑어봐야하는 상황을 의미
- 기능에 대한 욕심: 함수가 다른 객체의 데이터와 함수를 광범위하게 사용하는 상황


# DI 장점
- DI는 의존성을 추상적이거나 일반적인 방법으로 표현함으로 코드 일부분에 대한 작업을 진행할 때 필요한 지식을 줄여줌
- DI는 의존성을 격리시켜 코드 테스트에 이점을 준다
- DI를 통해 어렵거나 불가능한 상황을 구성하여 신속하고 안정적인 테스트가 가능하다
- DI는 코드를 확장하거나 변경할 때 영향력을 최소화한다

<br>

# SOLID
SOLID는 유명한 다섯 가지 객체지향 소프트웨어 디자인 원칙의 약자를 모은 것

- 단일 책임 원칙(SRP: Single Responsibility Principle)
- 개방/폐쇄 원칙(OCP: Open/Closed Principle)
- 리스코프 치환 원칙(LSP: Liskov Substitution Principle)
- 인터페이스 분리 원칙(ISP: Interface Segregation Principle)
- 의존성 역전 원칙(DIP: Dependency Inversion Principle)

### 단일 책임 원칙

### 개방/폐쇄 원칙

### 리스코프 치환 원칙

### 인터페이스 분리 원칙

### 의존성 역전 원칙
