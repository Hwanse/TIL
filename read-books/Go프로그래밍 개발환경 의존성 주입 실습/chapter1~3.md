
# 예상 독자
- 코드를 쉽게 읽고, 테스트하고, 유지 운영하길 원하는 개발자들을 위한 책
- Go언어를 통해 더 많은 것을 구현하길 원하는 객체지향에 익숙한 개발자에게 적합

## DI가 필요한 코드 냄새
DI는 프로그래밍 분야에서 매우 유용한 도구로 활용되나 특정 상황에 국한되어 있음. 이 책에서 말하는 DI가 필요한 특정상황은
바로 '코드 냄새'를 말하며, 코드 냄새란 다음과 같은 유형을 말한다

- 코드 팽창(code bloat)
- 변경에 대한 저항(resistance to change)
- 낭비되는 노력(wasted effort)
- 강한 결합(tight coupling)

### 코드 팽창
코드 팽창은 너무 길거나 읽기 힘든 수준의 코드가 구조체 또는 함수에 추가되어 이해가 어렵고 유지 운영 및 테스트가 힘든 경우를
말한다. 코드 팽창 냄새는 소스 코드를 정적 분석을 하거나 gocyclo 같은 순환 복잡도 검사기를 통해 찾을 수 있음.
다음과 같은 특징을 포함하는 코드가 '코드 팽창' 냄새가 나는 코드라 할 수 있다

- 너무 긴 메서드
- 거대한 구조체
- 너무 많은 인수(매개변수)
- 너무 긴 조건 블록

### 변경에 대한 저항
새로운 기능이 추가하는 행위가 어렵거나 오랜 시간을 소요하게 만드는 코드를 의미하며, 이러한 상황을 변경에 대한 저항성을 가진 코드라고 말한다. 변경에 저항을 가지는 코드는 다음과 같은 특징을 포함

- 변경의 분산: 하나의 작은 변경을 했을 경우 다른 코드에도 변경이 필요한 상황을 의미. 간단한 변경을 했을 뿐인데 많은 부분의 코드를 수정하는 것.
- 상세 구현 내용 노출: 예로 함수의 매개변수로 구조체를 전달받을 경우 해당 함수를 사용하는 사용자의 코드가 특정 조건에 제한된
동작 구현을 하게되고, 만일 함수의 세부 구현 내용이 변경될 경우 API가 변경되고 해당 함수의 사용자 또한 변경되는 상황.
  
### 낭비되는 노력
코드를 유지 운영하는 비용이 필요 이상으로 높은 상황을 말함. 노력이 낭비되는 상황을 유발하는 코드 유형은 다음과 같음

- 과도하게 중복된 코드
- 과도한 주석
- 중첩되고 복합한 코드
- DRY/WET 코드: DRY(Don't Repeat Yourself/중복 배제)는 책임을 그룹화하여 깔끔하게 정리된 추상화를 통해 개발 과정에서
모든 형태의 중복을 지향하는 원칙, 이와 대조적으로 WET(Waste Everyone's Time) 코드에서는 동일한 책임이 여러 곳에 산재되어
  있는 상황을 말함.
  
### 강한 결합
결합은 각 객체들이 서로 관련되어 있거나 의존하는 정도를 말하며, 두 객체 간에 결합의 정도가 강할 수록 상호 의존성 또한 강해져
한 객체가 변경되면 다른 객체도 그에 맞춰 같이 변경되는 상황을 말하고 이 또한 유지 운영 비용을 증가시키는 요소. 강한 결합 냄새가 나는 코드는 다음과 같은 특징을 포함함

- 신(God) 객체에 대한 의존: '신 객체'는 너무 많은 것을 알고 있거나 너무 많은 일을 수행하는 객체를 의미. 즉 하나의 객체에 너무 많은 코드가 의존하고 있는 상황
- 순환 종속성: Go 언어에서는 패키지 순환 참조를 의미
- 객체 섞임: 한 객체가 다른 객체의 내부 구조에 대해 너무 많이 알고 있거나 너무 많은 접근 권한을 가지고 있는 상황, 이럴 경우 한 객체가 변경되면 다른 객체도 변경되는 상황을 유발
- 요요 문제: 상속 관계가 너무 길고 복잡화 되어 개발자가 이 코드를 이해하기 위해서 서로 다른 부분을 계속 훑어봐야하는 상황을 의미
- 기능에 대한 욕심: 함수가 다른 객체의 데이터와 함수를 광범위하게 사용하는 상황


# DI 장점
- DI는 의존성을 추상적이거나 일반적인 방법으로 표현함으로 코드 일부분에 대한 작업을 진행할 때 필요한 지식을 줄여줌
- DI는 의존성을 격리시켜 코드 테스트에 이점을 준다
- DI를 통해 어렵거나 불가능한 상황을 구성하여 신속하고 안정적인 테스트가 가능하다
- DI는 코드를 확장하거나 변경할 때 영향력을 최소화한다

<br>

# SOLID
SOLID는 유명한 다섯 가지 객체지향 소프트웨어 디자인 원칙의 약자를 모은 것

- 단일 책임 원칙(SRP: Single Responsibility Principle)
- 개방/폐쇄 원칙(OCP: Open/Closed Principle)
- 리스코프 치환 원칙(LSP: Liskov Substitution Principle)
- 인터페이스 분리 원칙(ISP: Interface Segregation Principle)
- 의존성 역전 원칙(DIP: Dependency Inversion Principle)

### 단일 책임 원칙
`클래스는 하나의 기능만 가지며, 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다`
Go 언어에서는 클래스가 없지만 클래스를 객체(구조체, 함수, 인터페이스 혹은 패키지)로 대체하면 이 원칙을
적용할 수 있으며, 다음과 같은 장점이 있다

- 코드를 더 작고 더 간결한 조각으로 분해하여 복잡성을 줄인다
- 코드의 재사용 가능성을 높인다
- 좀 더 쉽게 테스트를 작성하고 유지 보수할 수 있도록 도운다

### 개방/폐쇄 원칙
`소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고 수정에는 닫혀있어야 한다`
여기서 '개방'은 새로운 패키지, 새로운 인터페이스 또는 기존의 인터페이스에 새로운 구현을 쉽게 추가할 수 있는 것을 의미, '폐쇄'는 다른 사람들이 사용하는 API에 대한 변경 사항을 최소화하는 것을 의미하며 다음과 같은 장점이 있다

- 추가 및 확장에 대한 위험을 줄이는 데 도움
- 기능을 추가하거나 제거할 때 필요한 변경 사항을 최소화하는 데 도움
- 버그가 발생할 수 있는 범위를 새롭게 추가된 코드와 해당 코드를 사용하는 부분으로 좁혀준다

### 리스코프 치환 원칙
`타입 S의 객체 o1과 타입 T의 인스턴스 o2가 있을 때, 어떤 프로그램에서 타입 T의 객체로 P가 사용된다고
하자, S가 T의 서브타입이라면 P에 대입된 o1이 o2로 치환된다고 해도 P의 행위는 바뀌지 않는다`
이 원칙의 내용은 제대로 이해가 가지 않는다. 이 내용을 다음과 같이 요약할 수 있음
`서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다`

LSP 원칙은 서브타입 간에 서로 대체 가능함을 요구한다. Golang 에서는 추상 클래스가 없기 때문에 인터페이스를 대체하여 활용이 가능하며, 다음과 같은 장점이 있다

- 동작에 대한 정의만 할 뿐이며 상세 구현은 하지 않는다

### 인터페이스 분리 원칙
`클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다`
이말은 다음과 같이 다시 정의할 수 있다. `인터페이스는 가능한 작은 단위로 분리해야 한다` 이 말은 즉, 
날씬한 인터페이스를 요구하는 것을 말하며, 다음과 같은 장점이 있다

- 날씬한 인터페이스를 정의하도록 요구한다
- ISP는 함수의 입력을 명확히 한다


### 의존성 역전 원칙
`상위 모듈은 하위 모듈에 의존해서는 안 된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.`
